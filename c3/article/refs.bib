@misc{12TechnicalInformations,
  title = {12. {{Technical Informations}} --- {{Why3}} 1.8.1 Documentation},
  urldate = {2025-07-03},
  howpublished = {https://www.why3.org/doc/technical.html},
  file = {/home/miguel/Zotero/storage/UGWKNZDI/technical.html}
}

@article{albalooshiComparativeStudyEffect2017,
  title = {A {{Comparative Study}} on the {{Effect}} of {{Multiple Inheritance Mechanism}} in {{Java}}, {{C}}++, and {{Python}} on {{Complexity}} and {{Reusability}} of {{Code}}},
  author = {Albalooshi, Fawzi and Mahmood, Amjad},
  year = {2017},
  journal = {International Journal of Advanced Computer Science and Applications},
  volume = {8},
  number = {6},
  issn = {21565570, 2158107X},
  doi = {10.14569/IJACSA.2017.080614},
  urldate = {2025-06-25},
  abstract = {Two of the fundamental uses of generalization in object-oriented software development are the reusability of code and better structuring of the description of objects. Multiple inheritance is one of the important features of object-oriented methodologies which enables developers to combine concepts and increase the reusability of the resulting software. However, multiple inheritance is implemented differently in commonly used programming languages. In this paper, we use Chidamber and Kemerer (CK) metrics to study the complexity and reusability of multiple inheritance as implemented in Python, Java, and C++. The analysis of results suggests that out of the three languages investigated Python and C++ offer better reusability of software when using multiple inheritance, whereas Java has major deficiencies when implementing multiple inheritance resulting in poor structure of objects.},
  langid = {english},
  file = {/home/miguel/Zotero/storage/6H7JALFU/Albalooshi and Mahmood - 2017 - A Comparative Study on the Effect of Multiple Inheritance Mechanism in Java, C++, and Python on Comp.pdf}
}

@inproceedings{barrettMonotonicSuperclassLinearization1996,
  title = {A Monotonic Superclass Linearization for {{Dylan}}},
  booktitle = {Proceedings of the 11th {{ACM SIGPLAN}} Conference on {{Object-oriented}} Programming, Systems, Languages, and Applications},
  author = {Barrett, Kim and Cassels, Bob and Haahr, Paul and Moon, David A. and Playford, Keith and Withington, P. Tucker},
  year = {1996},
  month = oct,
  series = {{{OOPSLA}} '96},
  pages = {69--82},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  doi = {10.1145/236337.236343},
  urldate = {2025-06-25},
  abstract = {Object-oriented languages with multiple inheritance and automatic conflict resolution typically use a linearization of superclasses to determine which version of a property to inherit when several superclasses provide definitions. Recent work has defined several desirable characteristics for linearizations, the most important being monotonicity, which prohibits inherited properties from skipping over direct superclasses. Combined with Dylan's sealing mechanism, a monotonic linearization enables some compile-time method selection that would otherwise be impossible in the absence of a closed-world assumption.The Dylan linearization is monotonic, easily described, strictly observes local precedence order, and produces the same ordering as CLOS when that is monotonic. We present an implementation based on merging and a survey of class heterarchies from several large programs, analyzing where commonly used linearizations differ.},
  isbn = {978-0-89791-788-9},
  file = {/home/miguel/Zotero/storage/DFYP3YLP/Barrett et al. - 1996 - A monotonic superclass linearization for Dylan.pdf}
}

@online{castanhoAutoactiveVerificationGraph2022,
  title = {Auto-Active {{Verification}} of {{Graph Algorithms}}, {{Written}} in {{OCaml}}},
  author = {Castanho, Daniel and Pereira, Mário},
  date = {2022-07-20},
  eprint = {2207.09854},
  eprinttype = {arXiv},
  eprintclass = {cs},
  doi = {10.48550/arXiv.2207.09854},
  url = {http://arxiv.org/abs/2207.09854},
  urldate = {2025-07-04},
  abstract = {Functional programming offers the perfect ground for building correct-by-construction software. Languages of such paradigm normally feature state-of-the-art type systems, good abstraction mechanisms, and well-defined execution models. We claim that all of these make software written in a functional language excellent targets for formal certification. Yet, somehow surprising, techniques such as deductive verification have been seldom applied to large-scale programs, written in mainstream functional languages. In this paper, we wish to address this situation and present the auto-active proof of realistic OCaml implementations. We choose implementations issued from the OCamlgraph library as our target, since this is both a large-scale and widely-used piece of OCaml code. We use Cameleer, a recently proposed tool for the deductive verification of OCaml programs, to conduct the proofs of the selected case studies. The vast majority of such proofs are completed fully-automatically, using SMT solvers, and when needed we can apply lightweight interactive proof inside the Why3 IDE (Cameleer translates an input program into an equivalent WhyML one, the language of the Why3 verification framework). To the best of our knowledge, these are the first mechanized, mostly-automated proofs of graph algorithms written in OCaml.},
  pubstate = {prepublished},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/miguel/Zotero/storage/KXJ7F8AY/Castanho and Pereira - 2022 - Auto-active Verification of Graph Algorithms, Written in OCaml.pdf;/home/miguel/Zotero/storage/8TLM4GZY/2207.html}
}

@inproceedings{chargueraudGOSPELProvidingOCaml2019,
  title = {{{GOSPEL}}---{{Providing OCaml}} with a {{Formal Specification Language}}},
  booktitle = {Formal {{Methods}} -- {{The Next}} 30 {{Years}}},
  author = {Chargu{\'e}raud, Arthur and Filli{\^a}tre, Jean-Christophe and Louren{\c c}o, Cl{\'a}udio and Pereira, M{\'a}rio},
  editor = {{ter Beek}, Maurice H. and McIver, Annabelle and Oliveira, Jos{\'e} N.},
  year = {2019},
  pages = {484--501},
  publisher = {Springer International Publishing},
  address = {Cham},
  doi = {10.1007/978-3-030-30942-8_29},
  abstract = {This paper introduces GOSPEL, a behavioral specification language for OCaml. It is designed to enable modular verification of data structures and algorithms. GOSPEL is a contract-based, strongly typed language, with a formal semantics defined by means of translation into Separation Logic. Compared with writing specifications directly in Separation Logic, GOSPEL provides a high-level syntax that greatly improves conciseness and makes it accessible to programmers with no familiarity with Separation Logic. Although GOSPEL has been developed for specifying OCaml code, we believe that many aspects of its design could apply to other programming languages. This paper presents the design and semantics of GOSPEL, and reports on its application for the development of a formally verified library of general-purpose OCaml data structures.},
  isbn = {978-3-030-30942-8},
  langid = {english}
}

@misc{Cvc5,
  title = {About Cvc5},
  journal = {cvc5},
  urldate = {2025-07-03},
  abstract = {An efficient open-source automatic theorem prover for satisfiability modulo theories (SMT) problems.},
  howpublished = {https://cvc5.github.io/},
  langid = {american},
  file = {/home/miguel/Zotero/storage/I8MXJKQK/cvc5.github.io.html}
}

@software{filliatreBacktrackingOcamlgraph2025,
  title = {Backtracking/Ocamlgraph},
  author = {Filliatre, Jean-Christophe},
  date = {2025-06-23T17:48:45Z},
  origdate = {2013-06-05T09:26:06Z},
  url = {https://github.com/backtracking/ocamlgraph},
  urldate = {2025-07-04},
  abstract = {OCaml graph library}
}

@inproceedings{filliatreWhy3WherePrograms2013,
  title = {Why3 — {{Where Programs Meet Provers}}},
  booktitle = {Programming {{Languages}} and {{Systems}}},
  author = {Filliâtre, Jean-Christophe and Paskevich, Andrei},
  editor = {Felleisen, Matthias and Gardner, Philippa},
  date = {2013},
  pages = {125--128},
  publisher = {Springer},
  location = {Berlin, Heidelberg},
  doi = {10.1007/978-3-642-37036-6_8},
  abstract = {We present Why3, a tool for deductive program verification, and WhyML, its programming and specification language. WhyML is a first-order language with polymorphic types, pattern matching, and inductive predicates. Programs can make use of record types with mutable fields, type invariants, and ghost code. Verification conditions are discharged by Why3 with the help of various existing automated and interactive theorem provers. To keep verification conditions tractable and comprehensible, WhyML imposes a static control of aliases that obviates the use of a memory model. A user can write WhyML programs directly and get correct-by-construction OCaml programs via an automated extraction mechanism. WhyML is also used as an intermediate language for the verification of C, Java, or Ada programs. We demonstrate the benefits of Why3 and WhyML on non-trivial examples of program verification.},
  isbn = {978-3-642-37036-6},
  langid = {english},
  keywords = {Abstract Data Type,Intermediate Language,Polymorphic Type,Proof Obligation,Type Invariant},
  file = {/home/miguel/Zotero/storage/NXWVWZB9/Filliâtre and Paskevich - 2013 - Why3 — Where Programs Meet Provers.pdf}
}

@inproceedings{filliatreWhy3WherePrograms2013a,
  title = {Why3 --- {{Where Programs Meet Provers}}},
  booktitle = {Programming {{Languages}} and {{Systems}}},
  author = {Filli{\^a}tre, Jean-Christophe and Paskevich, Andrei},
  editor = {Felleisen, Matthias and Gardner, Philippa},
  year = {2013},
  pages = {125--128},
  publisher = {Springer},
  address = {Berlin, Heidelberg},
  doi = {10.1007/978-3-642-37036-6_8},
  abstract = {We present Why3, a tool for deductive program verification, and WhyML, its programming and specification language. WhyML is a first-order language with polymorphic types, pattern matching, and inductive predicates. Programs can make use of record types with mutable fields, type invariants, and ghost code. Verification conditions are discharged by Why3 with the help of various existing automated and interactive theorem provers. To keep verification conditions tractable and comprehensible, WhyML imposes a static control of aliases that obviates the use of a memory model. A user can write WhyML programs directly and get correct-by-construction OCaml programs via an automated extraction mechanism. WhyML is also used as an intermediate language for the verification of C, Java, or Ada programs. We demonstrate the benefits of Why3 and WhyML on non-trivial examples of program verification.},
  isbn = {978-3-642-37036-6},
  langid = {english},
  keywords = {Abstract Data Type,Intermediate Language,Polymorphic Type,Proof Obligation,Type Invariant},
  file = {/home/miguel/Zotero/storage/TDHN7J7Y/Filliâtre and Paskevich - 2013 - Why3 — Where Programs Meet Provers.pdf}
}

@article{hivertControllingC3Super2024,
  title = {Controlling the {{C3 Super Class Linearization Algorithm}} for {{Large Hierarchies}} of {{Classes}}},
  author = {Hivert, Florent and Thi{\'e}ry, Nicolas M.},
  year = {2024},
  month = apr,
  journal = {Order},
  volume = {41},
  number = {1},
  pages = {83--98},
  issn = {1572-9273},
  doi = {10.1007/s11083-022-09607-5},
  urldate = {2025-06-25},
  abstract = {C3 is an algorithm used by several widely used programming languages such as Python to support multiple inheritance in object oriented programming (OOP): for each class, C3 computes recursively a linear extension of the poset of all its super classes (the Method Resolution Order, MRO) from user-provided local information (an ordering of the direct super classes). This algorithm can fail if the local information is not consistent. For large hierarchies of classes, as encountered when modeling hierarchies of concepts from abstract algebra in the SageMath computational system, maintaining consistent local information by hand does not scale and leads to unpredictable C3 failures. This paper reports on the authors' work to analyze and circumvent this maintenance nightmare. First, we discovered through extensive computer exploration that there exists posets admitting no consistent local information; we exhibit the smallest one which has 10 elements. Then, we provide and analyze an algorithm that, given a poset and a linear extension, automatically builds local information for C3 in such a way that guarantees that it will never fail, at the price of a slight relaxation of the hypotheses. This algorithm has been used in production in SageMath since 2013.},
  langid = {english},
  keywords = {Algorithmic Complexity,Algorithms,C3,C3 photosynthesis,Class hierarchies,Computability and Recursion Theory,Linear Algebra,Linear Logic,Linearization,Multiple inheritance},
  file = {/home/miguel/Zotero/storage/CVECDXTC/Hivert and Thiéry - 2024 - Controlling the C3 Super Class Linearization Algorithm for Large Hierarchies of Classes.pdf}
}

@misc{LanguageInfluencesSolidity,
  title = {Language {{Influences}} --- {{Solidity}} 0.8.31 Documentation},
  urldate = {2025-06-25},
  howpublished = {https://docs.soliditylang.org/en/latest/language-influences.html},
  file = {/home/miguel/Zotero/storage/7XE6HFQ5/language-influences.html}
}

@article{liNovelPerformanceEvaluation2019,
  title = {A Novel Performance Evaluation Model for {{MRO}} Management Indicators of High-End Equipment},
  author = {Li, Ling and , Min, Liu and , Weiming, Shen and {and Cheng}, Guoqing},
  year = {2019},
  month = nov,
  journal = {International Journal of Production Research},
  volume = {57},
  number = {21},
  pages = {6740--6757},
  publisher = {Taylor \& Francis},
  issn = {0020-7543},
  doi = {10.1080/00207543.2019.1566654},
  urldate = {2025-06-25},
  abstract = {High-end equipment oriented maintenance, repair and operation (MRO) management is crucial for asset intensive industries. The existing works mainly focus on providing the best possible joint optimisation for production and maintenance management without aiming at the complicated relationships among them. In the intelligence-connected era, the rapid development of Internet of things and big data technologies enables us to access, collect, and store the industrial big data, which is especially necessary for MRO management indicator evaluation, and so we try to apply big data analysis to visualise the system structure of complicated relationships among MRO indicators at different management levels. In this paper, the decision-making trial and evaluation laboratory (DEMATEL) and improved analytical network process (ANP) are applied to build the performance evaluation model for MRO management indicators, in which DEMATEL is utilised to quantify the system structure of different management levels, and the improved ANP is introduced to calculate relative weights of corresponding indicators. The results point out to managers which indicators should deserve more attention in MRO management decision-making as well as joint optimisation for production and maintenance management. A case study illustrates the feasibility and practicality of the proposed model.},
  keywords = {engineering management,evaluation model,high-end equipment,innovation management,interdependence,MRO management indicators},
  file = {/home/miguel/Zotero/storage/XAJLWPS8/Li et al. - 2019 - A novel performance evaluation model for MRO management indicators of high-end equipment.pdf}
}

@online{MiguelflorC3_ocaml_verified,
  title = {Miguelflor/C3\_ocaml\_verified},
  url = {https://github.com/miguelflor/c3_ocaml_verified},
  urldate = {2025-07-04},
  file = {/home/miguel/Zotero/storage/UEXKU888/c3_ocaml_verified.html}
}

@article{mondayezeStudiesObjectorientedProgramming2021,
  title = {Studies in Object-Oriented Programming Backbone Implementations},
  author = {{Monday Eze} and {Charles Okunbor} and {Umoke Chukwudum}},
  year = {2021},
  month = sep,
  journal = {Global Journal of Engineering and Technology Advances},
  volume = {8},
  number = {3},
  pages = {020--031},
  issn = {25825003},
  doi = {10.30574/gjeta.2021.8.3.0119},
  urldate = {2025-06-25},
  abstract = {This work is a combination of conceptual and hands on based study aimed at laying a foundation for practical ObjectOriented software construction. First it presents a conceptual study of a number of backbone concepts of modern Object-Oriented Programming (OOP) languages. Secondly, it attempts to demonstrate real-life implementations of these concepts using Python Programming Language. This work touches on practical issues on Class and Object Creation, especially on the syntax and creation, and demystifies the subject matter using a simple table of rules. The OOP concept of Inheritance was studied, with focus on the three major types of inheritance. The self-argument, and constructors were studied, with focus on the three constructors - default, parameterized, and non-parameterized constructors. A brief discussion, and pictorial illustration was also made on the disparity between normal mathematical functions and OOP method calls. Further areas of studies are the concept of overriding between the parent and child class, as well as the OOP puzzle commonly known as Diamond Problem, including code segment and diagrammatic illustration of Python-based solutions. There are a number of other back-bone concepts in OOP not covered in this study, such as Encapsulation, Abstraction, Meta-Programming, among others, which will form areas of focus in future studies. Effort was made to enhance the overall presentation through practical illustrations using source codes, annotated diagrams, and discussions. It is hoped that this work will be very useful to researchers and other practitioners in Object Oriented implementations.},
  langid = {english},
  file = {/home/miguel/Zotero/storage/GGSRINP8/Monday Eze et al. - 2021 - Studies in object-oriented programming backbone implementations.pdf}
}

@misc{MroMethodResolution,
  title = {Mro - {{Method Resolution Order}} - {{Perldoc Browser}}},
  urldate = {2025-06-25},
  howpublished = {https://perldoc.perl.org/mro},
  file = {/home/miguel/Zotero/storage/AKSWB23M/mro.html}
}

@inproceedings{pereiraCameleerDeductiveVerification2021,
  title = {Cameleer: {{A Deductive Verification Tool}} for {{OCaml}}},
  shorttitle = {Cameleer},
  booktitle = {Computer {{Aided Verification}}},
  author = {Pereira, M{\'a}rio and Ravara, Ant{\'o}nio},
  editor = {Silva, Alexandra and Leino, K. Rustan M.},
  year = {2021},
  pages = {677--689},
  publisher = {Springer International Publishing},
  address = {Cham},
  doi = {10.1007/978-3-030-81688-9_31},
  abstract = {We present Cameleer, an automated deductive verification tool for OCaml. We leverage on the recently proposed GOSPEL (Generic OCaml SPEcification Language) to attach rigorous, yet readable, behavioral specification to OCaml code. The formally-specified program is fed to our toolchain, which translates it into an equivalent one in WhyML, the programming and specification language of the Why3 verification framework. We report on successful case studies conducted in Cameleer.},
  isbn = {978-3-030-81688-9},
  langid = {english},
  keywords = {Deductive software verification,GOSPEL,OCaml,Why3},
  file = {/home/miguel/Zotero/storage/TGXYWWDK/Pereira and Ravara - 2021 - Cameleer A Deductive Verification Tool for OCaml.pdf}
}

@misc{Python23Method,
  title = {The {{Python}} 2.3 {{Method Resolution Order}}},
  journal = {Python documentation},
  urldate = {2025-06-25},
  abstract = {By Michele Simionato. Abstract, This document is intended for Python programmers who want to understand the C3 Method Resolution Order used in Python 2.3. Although it is not intended for newbies, i...},
  howpublished = {https://docs.python.org/3/howto/mro.html},
  langid = {english},
  file = {/home/miguel/Zotero/storage/JHINLBJJ/mro.html}
}

@online{Python23Methoda,
  title = {The {{Python}} 2.3 {{Method Resolution Order}}},
  url = {https://docs.python.org/3/howto/mro.html},
  urldate = {2025-07-04},
  abstract = {By Michele Simionato. Abstract, This document is intended for Python programmers who want to understand the C3 Method Resolution Order used in Python 2.3. Although it is not intended for newbies, i...},
  langid = {english},
  organization = {Python documentation},
  file = {/home/miguel/Zotero/storage/57RTVPZJ/mro.html}
}

@thesis{reisSoliderSolidity2023,
  type = {mathesis},
  title = {Towards a {{Solider Solidity}}},
  author = {family=Reis, given=João Carlos Raposo, prefix=dos, useprefix=false},
  date = {2023-12},
  url = {https://run.unl.pt/handle/10362/167656},
  urldate = {2025-07-04},
  abstract = {Blockchains are being widely adopted since its inception. Since Ethereum popularized smart contracts and introduced its platform for developing and deploying these programs on the blockchain, there has been an unprecedented boom in decentralized applications (dApps). Smart contracts bring a new flexibility which we didn’t see in the beginning with the first generation blockchains. These programs rule important agreements between two parties involving transacting valuable assets between them. Recently we have seen a record of stealing assets from the blockchain , as they exploded and became more popular in 2020. Many known vulnerabilities include: Re-entrancy, Gasless Send, Phishing with tx.origin and Type Casts. This reinforces the importance to ensure that these programs are correct. However this is still a hard task, as the programming languages used to developed them often do not really help and smart contracts are still being exploited. Static analysis tools can prevent these bugs, if they are robust enough to detect most of the vulnerabilities which are known and not known, and ensure that these contracts are developed with the best design practices. Many of those existing tools and programming languages are still in a very early stage and not yet prepared to be used in production environments. The development of smart contracts can be done in two types of languages: domain- specific and general-purpose languages. Domain-specific languages, specifically designed for writing smart contracts, are generally considered safer than their general-purpose counterparts. Solidity, created by the Ethereum Foundation, is a DSL and stands out as the most popular language to date. However, it is not without its flaws, primarily stemming from its complexity and Turing completeness. While recent academic efforts have introduced languages aimed at addressing known vulnerabilities in Solidity, the language’s widespread adoption needs continuous improvements to improve its safety. Our contribution targets a vulnerability in Solidity related to Type Casts. We introduce a proof-of-concept language inspired by Featherweight Solidity, a formalization of Solidity as a subset with an improved type system. Specifically, our language features an extended typing address to mitigate this vulnerability.},
  langid = {english},
  annotation = {Accepted: 2024-05-22T10:28:54Z},
  file = {/home/miguel/Zotero/storage/3D7G3P4V/Reis - 2023 - Towards a Solider Solidity.pdf}
}

@misc{sasAltErgoSMTSolver,
  title = {The {{Alt-Ergo SMT}} Solver by {{OCamlPro}}},
  author = {SAS, {\relax Oc}amlPro},
  urldate = {2025-07-03},
  abstract = {Alt-Ergo is an open-source automatic solver of mathematical formulas based on Satisfiability Modulo Theories (SMT). It is used by tools such as Why3, Frama-C, The Spark toolset, Caveat, EasyCrypt and Cubicle. AltErgo is maintained and distributed by the OCamlPro company since September 2013.},
  howpublished = {https://alt-ergo.ocamlpro.com},
  langid = {english},
  file = {/home/miguel/Zotero/storage/MX5KT5MD/alt-ergo.ocamlpro.com.html}
}

@misc{Z3ProverZ32025,
  title = {{{Z3Prover}}/Z3},
  year = {2025},
  month = jul,
  urldate = {2025-07-03},
  abstract = {The Z3 Theorem Prover},
  howpublished = {Z3 Theorem Prover}
}

@article{zhangC1C1LinearizationPlanar2011,
  title = {C1{$<$}math{$><$}msup Is="true"{$><$}mi Is="true"{$>$}{{C}}{$<$}/Mi{$><$}mn Is="true"{$>$}1{$<$}/Mn{$><$}/Msup{$><$}/Math{$>$} Linearization for Planar Contractions},
  author = {Zhang, Wenmeng and Zhang, Weinian},
  date = {2011-04-01},
  journaltitle = {Journal of Functional Analysis},
  shortjournal = {Journal of Functional Analysis},
  volume = {260},
  number = {7},
  pages = {2043--2063},
  issn = {0022-1236},
  doi = {10.1016/j.jfa.2010.12.029},
  url = {https://www.sciencedirect.com/science/article/pii/S002212361000501X},
  urldate = {2025-07-04},
  abstract = {C1 linearization is of special interests because it can distinguish characteristic directions of dynamical systems. It is known that planar C1,α contractions with a fixed point at the origin O admit C1,β linearization with sufficiently small β{$>$}0 if α=1 and admit C1,α linearization if (log|λ1|/log|λ2|)−1{$<$}α⩽1, where λ1 and λ2 are eigenvalues of the linear parts of the contractions at O with 0{$<$}|λ1|⩽|λ2|{$<$}1. In this paper we improve the lower bound of α to lower the condition of C1 linearization for planar contractions. Furthermore, we prove that the derivatives of transformations in our C1 linearization are Hölder continuous and give estimates for the Hölder exponent. Finally, we give a counter example to show that those estimates cannot be improved anymore.},
  keywords = {Contractions,Hölder continuous,Invariant curve,linearization,Regularity},
  file = {/home/miguel/Zotero/storage/MQTVDY7Y/Zhang and Zhang - 2011 - C1C1 linearization for pla.pdf;/home/miguel/Zotero/storage/DSSTVJ38/S002212361000501X.html}
}
