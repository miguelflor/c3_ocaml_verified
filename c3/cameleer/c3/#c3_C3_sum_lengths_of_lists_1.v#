(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require int.Abs.
Require int.MinMax.
Require int.ComputerDivision.
Require int.Power.
Require list.List.
Require list.Length.
Require list.Mem.
Require set.Fset.
Require list.Nth.
Require option.Option.
Require list.Append.
Require list.Reverse.
Require list.RevAppend.
Require list.NumOcc.

(* Why3 assumption *)
Inductive ref (a:Type) :=
  | ref'mk : a -> ref a.
Axiom ref_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (ref a).
Existing Instance ref_WhyType.
Arguments ref'mk {a}.

(* Why3 assumption *)
Definition contents {a:Type} {a_WT:WhyType a} (v:ref a) : a :=
  match v with
  | ref'mk x => x
  end.

Axiom seq : forall (a:Type), Type.
Parameter seq_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (seq a).
Existing Instance seq_WhyType.

Parameter length:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z.

Axiom length_nonnegative :
  forall {a:Type} {a_WT:WhyType a}, forall (s:seq a), (0%Z <= (length s))%Z.

Parameter get:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> a.

Parameter infix_eqeq:
  forall {a:Type} {a_WT:WhyType a}, seq a -> seq a -> Prop.

Axiom infix_eqeq'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a),
  infix_eqeq s1 s2 <->
  ((length s1) = (length s2)) /\
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (length s1))%Z ->
   ((get s1 i) = (get s2 i))).

Axiom infix_eqeq'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a), infix_eqeq s1 s2 -> (s1 = s2).

Parameter create:
  forall {a:Type} {a_WT:WhyType a}, Numbers.BinNums.Z ->
  (Numbers.BinNums.Z -> a) -> seq a.

Axiom create'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (len:Numbers.BinNums.Z) (f:Numbers.BinNums.Z -> a),
  (0%Z <= len)%Z -> ((length (create len f)) = len).

Axiom create'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (len:Numbers.BinNums.Z) (f:Numbers.BinNums.Z -> a),
  (0%Z <= len)%Z -> forall (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < len)%Z -> ((get (create len f) i) = (f i)).

Parameter empty: forall {a:Type} {a_WT:WhyType a}, seq a.

Axiom empty'def :
  forall {a:Type} {a_WT:WhyType a}, ((length (empty : seq a)) = 0%Z).

Parameter set:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> a -> seq a.

Parameter result:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> a ->
  Numbers.BinNums.Z -> a.

Axiom result'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a) (j:Numbers.BinNums.Z),
  ((j = i) -> ((result s i v j) = v)) /\
  (~ (j = i) -> ((result s i v j) = (get s j))).

Axiom set'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length s))%Z ->
  ((set s i v) = (create (length s) (result s i v))).

Axiom set'spec'1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length s))%Z -> ((length (set s i v)) = (length s)).

Axiom set'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length s))%Z -> ((get (set s i v) i) = v).

Axiom set'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length s))%Z -> forall (j:Numbers.BinNums.Z),
  ((0%Z <= j)%Z /\ (j < (length s))%Z) /\ ~ (j = i) ->
  ((get (set s i v) j) = (get s j)).

Parameter mixfix_lblsmnrb:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> a -> seq a.

Axiom mixfix_lblsmnrb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length s))%Z ->
  ((mixfix_lblsmnrb s i v) = (set s i v)).

(* Why3 assumption *)
Definition singleton {a:Type} {a_WT:WhyType a} (v:a) : seq a :=
  create 1%Z (fun (us:Numbers.BinNums.Z) => v).

Axiom singleton'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (v:a), ((length (singleton v)) = 1%Z).

Axiom singleton'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (v:a), ((get (singleton v) 0%Z) = v).

Parameter result1:
  forall {a:Type} {a_WT:WhyType a}, a -> seq a -> Numbers.BinNums.Z -> a.

Axiom result'def1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:seq a) (i:Numbers.BinNums.Z),
  ((i = 0%Z) -> ((result1 x s i) = x)) /\
  (~ (i = 0%Z) -> ((result1 x s i) = (get s (i - 1%Z)%Z))).

(* Why3 assumption *)
Definition cons {a:Type} {a_WT:WhyType a} (x:a) (s:seq a) : seq a :=
  create (1%Z + (length s))%Z (result1 x s).

Axiom cons'spec'1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:seq a), ((length (cons x s)) = (1%Z + (length s))%Z).

Axiom cons'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:seq a), ((get (cons x s) 0%Z) = x).

Axiom cons'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:seq a), forall (i:Numbers.BinNums.Z),
  (0%Z < i)%Z /\ (i <= (length s))%Z ->
  ((get (cons x s) i) = (get s (i - 1%Z)%Z)).

Parameter result2:
  forall {a:Type} {a_WT:WhyType a}, seq a -> a -> Numbers.BinNums.Z -> a.

Axiom result'def2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (x:a) (i:Numbers.BinNums.Z),
  ((i = (length s)) -> ((result2 s x i) = x)) /\
  (~ (i = (length s)) -> ((result2 s x i) = (get s i))).

(* Why3 assumption *)
Definition snoc {a:Type} {a_WT:WhyType a} (s:seq a) (x:a) : seq a :=
  create (1%Z + (length s))%Z (result2 s x).

Axiom snoc'spec'1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (x:a), ((length (snoc s x)) = (1%Z + (length s))%Z).

Axiom snoc'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (x:a), ((get (snoc s x) (length s)) = x).

Axiom snoc'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (x:a), forall (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (length s))%Z -> ((get (snoc s x) i) = (get s i)).

Parameter mixfix_lbdtdtrb:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z ->
  Numbers.BinNums.Z -> seq a.

Axiom mixfix_lbdtdtrb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= j)%Z /\ (j <= (length s))%Z ->
  ((mixfix_lbdtdtrb s i j) =
   (create (j - i)%Z (fun (k:Numbers.BinNums.Z) => get s (i + k)%Z))).

Axiom mixfix_lbdtdtrb'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= j)%Z /\ (j <= (length s))%Z ->
  ((length (mixfix_lbdtdtrb s i j)) = (j - i)%Z).

Axiom mixfix_lbdtdtrb'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= j)%Z /\ (j <= (length s))%Z ->
  forall (k:Numbers.BinNums.Z), (0%Z <= k)%Z /\ (k < (j - i)%Z)%Z ->
  ((get (mixfix_lbdtdtrb s i j) k) = (get s (i + k)%Z)).

Parameter mixfix_lb_dtdtrb:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> seq a.

Axiom mixfix_lb_dtdtrb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= (length s))%Z ->
  ((mixfix_lb_dtdtrb s i) = (mixfix_lbdtdtrb s i (length s))).

Parameter mixfix_lbdtdt_rb:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> seq a.

Axiom mixfix_lbdtdt_rb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (j:Numbers.BinNums.Z),
  (0%Z <= j)%Z /\ (j <= (length s))%Z ->
  ((mixfix_lbdtdt_rb s j) = (mixfix_lbdtdtrb s 0%Z j)).

Parameter result3:
  forall {a:Type} {a_WT:WhyType a}, seq a -> seq a -> Numbers.BinNums.Z ->
  Numbers.BinNums.Z -> a.

Axiom result'def3 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a) (l:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  ((i < l)%Z -> ((result3 s1 s2 l i) = (get s1 i))) /\
  (~ (i < l)%Z -> ((result3 s1 s2 l i) = (get s2 (i - l)%Z))).

(* Why3 assumption *)
Definition infix_plpl {a:Type} {a_WT:WhyType a} (s1:seq a) (s2:seq a) : seq a :=
  let l := length s1 in create (l + (length s2))%Z (result3 s1 s2 l).

Axiom infix_plpl'spec'1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a),
  ((length (infix_plpl s1 s2)) = ((length s1) + (length s2))%Z).

Axiom infix_plpl'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a), forall (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (length s1))%Z ->
  ((get (infix_plpl s1 s2) i) = (get s1 i)).

Axiom infix_plpl'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a), forall (i:Numbers.BinNums.Z),
  ((length s1) <= i)%Z /\ (i < (length (infix_plpl s1 s2)))%Z ->
  ((get (infix_plpl s1 s2) i) = (get s2 (i - (length s1))%Z)).

(* Why3 assumption *)
Definition sequence (a:Type) := seq a.

(* Why3 assumption *)
Fixpoint of_list {a:Type} {a_WT:WhyType a}
  (l:Init.Datatypes.list a) {struct l}: seq a :=
  match l with
  | Init.Datatypes.nil => empty : seq a
  | Init.Datatypes.cons x r => cons x (of_list r)
  end.

Axiom length_of_list :
  forall {a:Type} {a_WT:WhyType a},
  forall (l:Init.Datatypes.list a),
  ((length (of_list l)) = (list.Length.length l)).

(* Why3 assumption *)
Definition point_wise {a:Type} {a_WT:WhyType a} (s:seq a)
    (l:Init.Datatypes.list a) : Prop :=
  forall (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (list.Length.length l))%Z ->
  ((Init.Datatypes.Some (get s i)) = (list.Nth.nth i l)).

Axiom elts_seq_of_list :
  forall {a:Type} {a_WT:WhyType a},
  forall (l:Init.Datatypes.list a), point_wise (of_list l) l.

Axiom is_of_list :
  forall {a:Type} {a_WT:WhyType a},
  forall (l:Init.Datatypes.list a) (s:seq a),
  ((list.Length.length l) = (length s)) -> point_wise s l ->
  infix_eqeq s (of_list l).

Axiom of_list_app :
  forall {a:Type} {a_WT:WhyType a},
  forall (l1:Init.Datatypes.list a) (l2:Init.Datatypes.list a),
  infix_eqeq (of_list (Init.Datatypes.app l1 l2))
  (infix_plpl (of_list l1) (of_list l2)).

Axiom of_list_app_length :
  forall {a:Type} {a_WT:WhyType a},
  forall (l1:Init.Datatypes.list a) (l2:Init.Datatypes.list a),
  ((length (of_list (Init.Datatypes.app l1 l2))) =
   ((list.Length.length l1) + (list.Length.length l2))%Z).

Axiom of_list_snoc :
  forall {a:Type} {a_WT:WhyType a},
  forall (l:Init.Datatypes.list a) (x:a),
  infix_eqeq
  (of_list (Init.Datatypes.app l (Init.Datatypes.cons x Init.Datatypes.nil)))
  (snoc (of_list l) x).

Parameter to_list:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Init.Datatypes.list a.

Axiom to_list_empty :
  forall {a:Type} {a_WT:WhyType a},
  ((to_list (empty : seq a)) = Init.Datatypes.nil).

Axiom to_list_cons :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a), (0%Z < (length s))%Z ->
  ((to_list s) =
   (Init.Datatypes.cons (get s 0%Z) (to_list (mixfix_lb_dtdtrb s 1%Z)))).

Axiom to_list_length :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a), ((list.Length.length (to_list s)) = (length s)).

Axiom to_list_nth :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (length s))%Z ->
  ((list.Nth.nth i (to_list s)) = (Init.Datatypes.Some (get s i))).

Axiom to_list_def_cons :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (x:a),
  ((to_list (cons x s)) = (Init.Datatypes.cons x (to_list s))).

Axiom convolution_to_of_list :
  forall {a:Type} {a_WT:WhyType a},
  forall (l:Init.Datatypes.list a), ((to_list (of_list l)) = l).

(* Why3 assumption *)
Definition t (a:Type) := seq a.

(* Why3 assumption *)
Definition mem {a:Type} {a_WT:WhyType a} (x:a) (s:seq a) : Prop :=
  exists i:Numbers.BinNums.Z,
  ((0%Z <= i)%Z /\ (i < (length s))%Z) /\ ((get s i) = x).

Axiom mem_append :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s1:seq a) (s2:seq a),
  mem x (infix_plpl s1 s2) <-> mem x s1 \/ mem x s2.

Axiom mem_tail :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:seq a), (0%Z < (length s))%Z ->
  mem x s <-> (x = (get s 0%Z)) \/ mem x (mixfix_lb_dtdtrb s 1%Z).

(* Why3 assumption *)
Definition reverse {a:Type} {a_WT:WhyType a} (s:seq a) : seq a :=
  create (length s)
  (fun (i:Numbers.BinNums.Z) => get s (((length s) - 1%Z)%Z - i)%Z).

(* Why3 assumption *)
Definition fst {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    (x:(a* b)%type) : a :=
  match x with
  | (r, _) => r
  end.

(* Why3 assumption *)
Definition snd {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    (x:(a* b)%type) : b :=
  match x with
  | (_, r) => r
  end.

(* Why3 assumption *)
Inductive result4 (a:Type)
  (b:Type) :=
  | Ok : a -> result4 a b
  | Error : b -> result4 a b.
Axiom result4_WhyType : forall (a:Type) {a_WT:WhyType a}
  (b:Type) {b_WT:WhyType b}, WhyType (result4 a b).
Existing Instance result4_WhyType.
Arguments Ok {a} {b}.
Arguments Error {a} {b}.

Parameter same_location: forall {a:Type} {a_WT:WhyType a}, a -> a -> Prop.

Axiom same_location_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (y:a), same_location x y -> (x = y).

Parameter infix_tleq:
  Numbers.BinNums.Z -> Numbers.BinNums.Z -> Init.Datatypes.bool.

Axiom infix_tleq'spec :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  ((infix_tleq x y) = Init.Datatypes.true) <-> ~ (x = y).

(* Why3 assumption *)
Definition is_pre_order {a:Type} {a_WT:WhyType a}
    (cmp:a -> a -> Numbers.BinNums.Z) : Prop :=
  (forall (x:a), ((cmp x x) = 0%Z)) /\
  (forall (x:a) (y:a), ((cmp x y) = 0%Z) <-> ((cmp y x) = 0%Z)) /\
  (forall (x:a) (y:a), ((cmp x y) < 0%Z)%Z <-> (0%Z < (cmp y x))%Z) /\
  (forall (x:a) (y:a) (z:a),
   (((cmp x y) = 0%Z) -> ((cmp y z) = 0%Z) -> ((cmp x z) = 0%Z)) /\
   (((cmp x y) = 0%Z) -> ((cmp y z) < 0%Z)%Z -> ((cmp x z) < 0%Z)%Z) /\
   (((cmp x y) < 0%Z)%Z -> ((cmp y z) = 0%Z) -> ((cmp x z) < 0%Z)%Z) /\
   (((cmp x y) < 0%Z)%Z -> ((cmp y z) < 0%Z)%Z -> ((cmp x z) < 0%Z)%Z)).

Axiom cmp_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (y:a) (cmp:a -> a -> Numbers.BinNums.Z), is_pre_order cmp ->
  ((cmp x y) = 0%Z) <-> (x = y).

Parameter compare:
  forall {a:Type} {a_WT:WhyType a}, a -> a -> Numbers.BinNums.Z.

Axiom compare_pre_order :
  forall {a:Type} {a_WT:WhyType a},
  is_pre_order (fun (x:a) (y:a) => compare x y).

Parameter concat:
  Strings.String.string -> Strings.String.string -> Strings.String.string.

Axiom concat_assoc :
  forall (s1:Strings.String.string) (s2:Strings.String.string)
    (s3:Strings.String.string),
  ((concat (concat s1 s2) s3) = (concat s1 (concat s2 s3))).

Parameter rliteral: Strings.String.string.

Axiom rliteral_axiom : True.

Axiom concat_empty :
  forall (s:Strings.String.string),
  ((concat s rliteral) = (concat rliteral s)) /\ ((concat rliteral s) = s).

Parameter length1: Strings.String.string -> Numbers.BinNums.Z.

Axiom length_empty : ((length1 rliteral) = 0%Z).

Axiom length_concat :
  forall (s1:Strings.String.string) (s2:Strings.String.string),
  ((length1 (concat s1 s2)) = ((length1 s1) + (length1 s2))%Z).

Parameter lt: Strings.String.string -> Strings.String.string -> Prop.

Axiom lt_empty :
  forall (s:Strings.String.string), ~ (s = rliteral) -> lt rliteral s.

Axiom lt_not_com :
  forall (s1:Strings.String.string) (s2:Strings.String.string), lt s1 s2 ->
  ~ lt s2 s1.

Axiom lt_ref : forall (s1:Strings.String.string), ~ lt s1 s1.

Axiom lt_trans :
  forall (s1:Strings.String.string) (s2:Strings.String.string)
    (s3:Strings.String.string),
  lt s1 s2 /\ lt s2 s3 -> lt s1 s3.

Parameter le: Strings.String.string -> Strings.String.string -> Prop.

Axiom le_empty : forall (s:Strings.String.string), le rliteral s.

Axiom le_ref : forall (s1:Strings.String.string), le s1 s1.

Axiom lt_le :
  forall (s1:Strings.String.string) (s2:Strings.String.string), lt s1 s2 ->
  le s1 s2.

Axiom lt_le_eq :
  forall (s1:Strings.String.string) (s2:Strings.String.string), le s1 s2 ->
  lt s1 s2 \/ (s1 = s2).

Axiom le_trans :
  forall (s1:Strings.String.string) (s2:Strings.String.string)
    (s3:Strings.String.string),
  le s1 s2 /\ le s2 s3 -> le s1 s3.

Parameter s_at:
  Strings.String.string -> Numbers.BinNums.Z -> Strings.String.string.

Axiom at_out_of_range :
  forall (s:Strings.String.string) (i:Numbers.BinNums.Z),
  (i < 0%Z)%Z \/ ((length1 s) <= i)%Z -> ((s_at s i) = rliteral).

Axiom at_empty :
  forall (i:Numbers.BinNums.Z), ((s_at rliteral i) = rliteral).

Axiom at_length :
  forall (s:Strings.String.string) (i:Numbers.BinNums.Z),
  let j := s_at s i in
  ((0%Z <= i)%Z /\ (i < (length1 s))%Z -> ((length1 j) = 1%Z)) /\
  (~ ((0%Z <= i)%Z /\ (i < (length1 s))%Z) -> ((length1 j) = 0%Z)).

Axiom concat_at :
  forall (s1:Strings.String.string) (s2:Strings.String.string),
  let s := concat s1 s2 in
  forall (i:Numbers.BinNums.Z),
  ((0%Z <= i)%Z /\ (i < (length1 s1))%Z -> ((s_at s i) = (s_at s1 i))) /\
  (((length1 s1) <= i)%Z /\ (i < (length1 s))%Z ->
   ((s_at s i) = (s_at s2 (i - (length1 s1))%Z))).

Parameter substring:
  Strings.String.string -> Numbers.BinNums.Z -> Numbers.BinNums.Z ->
  Strings.String.string.

Axiom substring_out_of_range :
  forall (s:Strings.String.string) (i:Numbers.BinNums.Z)
    (x:Numbers.BinNums.Z),
  (i < 0%Z)%Z \/ ((length1 s) <= i)%Z -> ((substring s i x) = rliteral).

Axiom substring_of_length_zero_or_less :
  forall (s:Strings.String.string) (i:Numbers.BinNums.Z)
    (x:Numbers.BinNums.Z),
  (x <= 0%Z)%Z -> ((substring s i x) = rliteral).

Axiom substring_of_empty :
  forall (i:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  ((substring rliteral i x) = rliteral).

Axiom substring_smaller :
  forall (s:Strings.String.string) (i:Numbers.BinNums.Z)
    (x:Numbers.BinNums.Z),
  ((length1 (substring s i x)) <= (length1 s))%Z.

Axiom substring_smaller_x :
  forall (s:Strings.String.string) (i:Numbers.BinNums.Z)
    (x:Numbers.BinNums.Z),
  (0%Z <= x)%Z -> ((length1 (substring s i x)) <= x)%Z.

Axiom substring_length :
  forall (s:Strings.String.string) (i:Numbers.BinNums.Z)
    (x:Numbers.BinNums.Z),
  (0%Z <= x)%Z /\ (0%Z <= i)%Z /\ (i < (length1 s))%Z ->
  (((length1 s) < (i + x)%Z)%Z ->
   ((length1 (substring s i x)) = ((length1 s) - i)%Z)) /\
  (~ ((length1 s) < (i + x)%Z)%Z -> ((length1 (substring s i x)) = x)).

Axiom substring_at :
  forall (s:Strings.String.string) (i:Numbers.BinNums.Z),
  ((s_at s i) = (substring s i 1%Z)).

Axiom substring_substring :
  forall (s:Strings.String.string) (ofs:Numbers.BinNums.Z)
    (len:Numbers.BinNums.Z) (ofs':Numbers.BinNums.Z) (len':Numbers.BinNums.Z),
  (0%Z <= ofs)%Z /\ (ofs <= (length1 s))%Z -> (0%Z <= len)%Z ->
  ((ofs + len)%Z <= (length1 s))%Z -> (0%Z <= ofs')%Z /\ (ofs' <= len)%Z ->
  (0%Z <= len')%Z -> ((ofs' + len')%Z <= len)%Z ->
  ((substring (substring s ofs len) ofs' len') =
   (substring s (ofs + ofs')%Z len')).

Axiom concat_substring :
  forall (s:Strings.String.string) (ofs:Numbers.BinNums.Z)
    (len:Numbers.BinNums.Z) (len':Numbers.BinNums.Z),
  (0%Z <= ofs)%Z /\ (ofs <= (length1 s))%Z -> (0%Z <= len)%Z ->
  ((ofs + len)%Z <= (length1 s))%Z -> (0%Z <= len')%Z ->
  (0%Z <= ((ofs + len)%Z + len')%Z)%Z /\
  (((ofs + len)%Z + len')%Z <= (length1 s))%Z ->
  ((concat (substring s ofs len) (substring s (ofs + len)%Z len')) =
   (substring s ofs (len + len')%Z)).

Parameter prefixof: Strings.String.string -> Strings.String.string -> Prop.

Axiom prefixof_substring :
  forall (s1:Strings.String.string) (s2:Strings.String.string),
  prefixof s1 s2 <-> (s1 = (substring s2 0%Z (length1 s1))).

Axiom prefixof_concat :
  forall (s1:Strings.String.string) (s2:Strings.String.string),
  prefixof s1 (concat s1 s2).

Axiom prefixof_empty :
  forall (s2:Strings.String.string), prefixof rliteral s2.

Axiom prefixof_empty2 :
  forall (s1:Strings.String.string), ~ (s1 = rliteral) ->
  ~ prefixof s1 rliteral.

Parameter suffixof: Strings.String.string -> Strings.String.string -> Prop.

Axiom suffixof_substring :
  forall (s1:Strings.String.string) (s2:Strings.String.string),
  suffixof s1 s2 <->
  (s1 = (substring s2 ((length1 s2) - (length1 s1))%Z (length1 s1))).

Axiom suffixof_concat :
  forall (s1:Strings.String.string) (s2:Strings.String.string),
  suffixof s2 (concat s1 s2).

Axiom suffixof_empty :
  forall (s2:Strings.String.string), suffixof rliteral s2.

Axiom suffixof_empty2 :
  forall (s1:Strings.String.string), ~ (s1 = rliteral) ->
  ~ suffixof s1 rliteral.

Parameter contains: Strings.String.string -> Strings.String.string -> Prop.

Axiom contains_prefixof :
  forall (s1:Strings.String.string) (s2:Strings.String.string),
  prefixof s1 s2 -> contains s2 s1.

Axiom contains_suffixof :
  forall (s1:Strings.String.string) (s2:Strings.String.string),
  suffixof s1 s2 -> contains s2 s1.

Axiom contains_empty :
  forall (s2:Strings.String.string), contains rliteral s2 <-> (s2 = rliteral).

Axiom contains_empty2 :
  forall (s1:Strings.String.string), contains s1 rliteral.

Axiom contains_substring :
  forall (s1:Strings.String.string) (s2:Strings.String.string)
    (i:Numbers.BinNums.Z),
  ((substring s1 i (length1 s2)) = s2) -> contains s1 s2.

Axiom contains_concat :
  forall (s1:Strings.String.string) (s2:Strings.String.string),
  contains (concat s1 s2) s1 /\ contains (concat s1 s2) s2.

Axiom contains_at :
  forall (s1:Strings.String.string) (s2:Strings.String.string)
    (i:Numbers.BinNums.Z),
  ((s_at s1 i) = s2) -> contains s1 s2.

Parameter indexof:
  Strings.String.string -> Strings.String.string -> Numbers.BinNums.Z ->
  Numbers.BinNums.Z.

Axiom indexof_empty :
  forall (s:Strings.String.string) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= (length1 s))%Z -> ((indexof s rliteral i) = i).

Axiom indexof_empty1 :
  forall (s:Strings.String.string) (i:Numbers.BinNums.Z),
  let j := indexof rliteral s i in
  (j = (-1%Z)%Z) \/ (s = rliteral) /\ (i = j) /\ (j = 0%Z).

Axiom indexof_contains :
  forall (s1:Strings.String.string) (s2:Strings.String.string),
  let j := indexof s1 s2 0%Z in
  contains s1 s2 ->
  ((0%Z <= j)%Z /\ (j <= (length1 s1))%Z) /\
  ((substring s1 j (length1 s2)) = s2).

Axiom contains_indexof :
  forall (s1:Strings.String.string) (s2:Strings.String.string)
    (i:Numbers.BinNums.Z),
  (0%Z <= (indexof s1 s2 i))%Z -> contains s1 s2.

Axiom not_contains_indexof :
  forall (s1:Strings.String.string) (s2:Strings.String.string)
    (i:Numbers.BinNums.Z),
  ~ contains s1 s2 -> ((indexof s1 s2 i) = (-1%Z)%Z).

Axiom substring_indexof :
  forall (s1:Strings.String.string) (s2:Strings.String.string)
    (i:Numbers.BinNums.Z),
  let j := indexof s1 s2 i in
  (0%Z <= j)%Z -> ((substring s1 j (length1 s2)) = s2).

Axiom indexof_out_of_range :
  forall (i:Numbers.BinNums.Z) (s1:Strings.String.string)
    (s2:Strings.String.string),
  ~ ((0%Z <= i)%Z /\ (i <= (length1 s1))%Z) -> ((indexof s1 s2 i) = (-1%Z)%Z).

Axiom indexof_in_range :
  forall (s1:Strings.String.string) (s2:Strings.String.string)
    (i:Numbers.BinNums.Z),
  let j := indexof s1 s2 i in
  (0%Z <= i)%Z /\ (i <= (length1 s1))%Z ->
  (j = (-1%Z)%Z) \/ (i <= j)%Z /\ (j <= (length1 s1))%Z.

Axiom indexof_contains_substring :
  forall (s1:Strings.String.string) (s2:Strings.String.string)
    (i:Numbers.BinNums.Z),
  ((0%Z <= i)%Z /\ (i <= (length1 s1))%Z) /\
  contains (substring s1 i ((length1 s1) - i)%Z) s2 ->
  (i <= (indexof s1 s2 i))%Z /\ ((indexof s1 s2 i) <= (length1 s1))%Z.

Parameter replace:
  Strings.String.string -> Strings.String.string -> Strings.String.string ->
  Strings.String.string.

Axiom replace_empty :
  forall (s1:Strings.String.string) (s3:Strings.String.string),
  ((replace s1 rliteral s3) = (concat s3 s1)).

Axiom replace_not_contains :
  forall (s1:Strings.String.string) (s2:Strings.String.string)
    (s3:Strings.String.string),
  ~ contains s1 s2 -> ((replace s1 s2 s3) = s1).

Axiom replace_empty2 :
  forall (s2:Strings.String.string) (s3:Strings.String.string),
  let s4 := replace rliteral s2 s3 in
  ((s2 = rliteral) -> (s4 = s3)) /\ (~ (s2 = rliteral) -> (s4 = rliteral)).

Axiom replace_substring_indexof :
  forall (s1:Strings.String.string) (s2:Strings.String.string)
    (s3:Strings.String.string),
  let j := indexof s1 s2 0%Z in
  ((j < 0%Z)%Z -> ((replace s1 s2 s3) = s1)) /\
  (~ (j < 0%Z)%Z ->
   ((replace s1 s2 s3) =
    (concat (concat (substring s1 0%Z j) s3)
     (substring s1 (j + (length1 s2))%Z
      (((length1 s1) - j)%Z - (length1 s2))%Z)))).

Parameter replaceall:
  Strings.String.string -> Strings.String.string -> Strings.String.string ->
  Strings.String.string.

Axiom replaceall_empty1 :
  forall (s1:Strings.String.string) (s3:Strings.String.string),
  ((replaceall s1 rliteral s3) = s1).

Axiom not_contains_replaceall :
  forall (s1:Strings.String.string) (s2:Strings.String.string)
    (s3:Strings.String.string),
  ~ contains s1 s2 -> ((replaceall s1 s2 s3) = s1).

Parameter to_int: Strings.String.string -> Numbers.BinNums.Z.

Axiom to_int_gt_minus_1 :
  forall (s:Strings.String.string), ((-1%Z)%Z <= (to_int s))%Z.

Axiom to_int_empty : ((to_int rliteral) = (-1%Z)%Z).

(* Why3 assumption *)
Definition is_digit (s:Strings.String.string) : Prop :=
  ((0%Z <= (to_int s))%Z /\ ((to_int s) <= 9%Z)%Z) /\ ((length1 s) = 1%Z).

Parameter from_int: Numbers.BinNums.Z -> Strings.String.string.

Axiom from_int_negative :
  forall (i:Numbers.BinNums.Z), (i < 0%Z)%Z <-> ((from_int i) = rliteral).

Axiom from_int_to_int :
  forall (i:Numbers.BinNums.Z),
  ((0%Z <= i)%Z -> ((to_int (from_int i)) = i)) /\
  (~ (0%Z <= i)%Z -> ((to_int (from_int i)) = (-1%Z)%Z)).

Axiom my_array : forall (a:Type), Type.
Parameter my_array_WhyType :
  forall (a:Type) {a_WT:WhyType a}, WhyType (my_array a).
Existing Instance my_array_WhyType.

Parameter elts: forall {a:Type} {a_WT:WhyType a}, my_array a -> seq a.

Parameter length2:
  forall {a:Type} {a_WT:WhyType a}, my_array a -> Numbers.BinNums.Z.

Axiom my_array'invariant :
  forall {a:Type} {a_WT:WhyType a},
  forall (self:my_array a),
  (0%Z <= (length2 self))%Z /\ ((length2 self) = (length (elts self))).

(* Why3 assumption *)
Definition mixfix_lbrb {a:Type} {a_WT:WhyType a} (a1:my_array a)
    (i:Numbers.BinNums.Z) : a :=
  get (elts a1) i.

Parameter to_list_range:
  forall {a:Type} {a_WT:WhyType a}, my_array a -> Numbers.BinNums.Z ->
  Numbers.BinNums.Z -> Init.Datatypes.list a.

Axiom to_list_range'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:my_array a) (l:Numbers.BinNums.Z) (u:Numbers.BinNums.Z),
  (0%Z <= l)%Z /\ (u <= (length2 a1))%Z ->
  ((u <= l)%Z -> ((to_list_range a1 l u) = Init.Datatypes.nil)) /\
  (~ (u <= l)%Z ->
   ((to_list_range a1 l u) =
    (Init.Datatypes.cons (mixfix_lbrb a1 l) (to_list_range a1 (l + 1%Z)%Z u)))).

Axiom to_list_append :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:my_array a) (l:Numbers.BinNums.Z) (m:Numbers.BinNums.Z)
    (u:Numbers.BinNums.Z),
  (0%Z <= l)%Z /\ (l <= m)%Z /\ (m <= u)%Z /\ (u <= (length2 a1))%Z ->
  ((Init.Datatypes.app (to_list_range a1 l m) (to_list_range a1 m u)) =
   (to_list_range a1 l u)).

(* Why3 assumption *)
Definition mem1 {a:Type} {a_WT:WhyType a} (x:a) (a1:my_array a) : Prop :=
  mem x (elts a1).

(* Why3 assumption *)
Definition array (a:Type) := my_array a.

Parameter max_array_length: Numbers.BinNums.Z.

Axiom non_neg_max_array_length : (0%Z < max_array_length)%Z.

(* Why3 assumption *)
Fixpoint map {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b} (f:a -> b)
  (l:Init.Datatypes.list a) {struct l}: Init.Datatypes.list b :=
  match l with
  | Init.Datatypes.nil => Init.Datatypes.nil
  | Init.Datatypes.cons x r => Init.Datatypes.cons (f x) (map f r)
  end.

(* Why3 assumption *)
Definition set1 (a:Type) := set.Fset.fset a.

(* Why3 assumption *)
Definition t1 (a:Type) := set.Fset.fset a.

(* Why3 assumption *)
Fixpoint elements {a:Type} {a_WT:WhyType a}
  (l:Init.Datatypes.list a) {struct l}: set.Fset.fset a :=
  match l with
  | Init.Datatypes.nil => set.Fset.empty : set.Fset.fset a
  | Init.Datatypes.cons x r => set.Fset.add x (elements r)
  end.

Axiom elements_mem :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (l:Init.Datatypes.list a),
  list.Mem.mem x l <-> set.Fset.mem x (elements l).

Axiom t2 : forall (a:Type), Type.
Parameter t2_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (t2 a).
Existing Instance t2_WhyType.

Parameter view: forall {a:Type} {a_WT:WhyType a}, t2 a -> seq a.

Axiom t3 : forall (a:Type), Type.
Parameter t3_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (t3 a).
Existing Instance t3_WhyType.

Parameter view1: forall {a:Type} {a_WT:WhyType a}, t3 a -> seq a.

(* Why3 assumption *)
Definition t4 := Strings.String.string.

Parameter compare1:
  Strings.String.string -> Strings.String.string -> Numbers.BinNums.Z.

Axiom compare_pre_order1 :
  is_pre_order
  (fun (y0:Strings.String.string) (y1:Strings.String.string) =>
   compare1 y0 y1).

(* Why3 assumption *)
Definition t5 := Numbers.BinNums.Z.

Parameter compare2:
  Numbers.BinNums.Z -> Numbers.BinNums.Z -> Numbers.BinNums.Z.

Axiom compare_pre_order2 :
  is_pre_order
  (fun (y0:Numbers.BinNums.Z) (y1:Numbers.BinNums.Z) => compare2 y0 y1).

Axiom t6 : Type.
Parameter t6_WhyType : WhyType t6.
Existing Instance t6_WhyType.

Parameter get_parents: t6 -> Init.Datatypes.list t6.

Axiom t7 : Type.
Parameter t7_WhyType : WhyType t7.
Existing Instance t7_WhyType.

Parameter get_parents1: t7 -> Init.Datatypes.list t7.

(* Why3 assumption *)
Fixpoint sum_lengths
  (ll:Init.Datatypes.list (Init.Datatypes.list t7)) {struct ll}: Numbers.BinNums.Z :=
  match ll with
  | Init.Datatypes.nil => 0%Z
  | Init.Datatypes.cons h t8 => ((list.Length.length h) + (sum_lengths t8))%Z
  end.

Fixpoint sum_lengths 


(* Why3 assumption *)
Definition is_removed (l:Init.Datatypes.list t7) (r:Init.Datatypes.list t7)
    (e:t7) : Prop :=
  match l with
  | Init.Datatypes.nil => (Init.Datatypes.nil = r)
  | Init.Datatypes.cons h t8 =>
      ((h = e) -> (t8 = r)) /\ (~ (h = e) -> (l = r))
  end.

(* Why3 assumption *)
Definition has_head (a:Init.Datatypes.list t7) (e:t7) : Prop :=
  match a with
  | Init.Datatypes.nil => False
  | Init.Datatypes.cons h _ => (h = e)
  end.

(* Why3 assumption *)
Definition tail (l:Init.Datatypes.list t7) : Init.Datatypes.list t7 :=
  match l with
  | Init.Datatypes.nil => Init.Datatypes.nil
  | Init.Datatypes.cons _ t8 => t8
  end.

(* Why3 assumption *)
Fixpoint distinct (l:Init.Datatypes.list t7) {struct l}: Prop :=
  match l with
  | Init.Datatypes.nil => True
  | Init.Datatypes.cons h t8 => ~ list.Mem.mem h t8 /\ distinct t8
  end.

Axiom is_removed_not_mem :
  forall (l:Init.Datatypes.list t7) (r:Init.Datatypes.list t7) (e:t7),
  is_removed l r e /\ ~ list.Mem.mem e (tail l) -> ~ list.Mem.mem e r.

Axiom is_removed_length :
  forall (l:Init.Datatypes.list t7) (r:Init.Datatypes.list t7) (e:t7),
  is_removed l r e /\ has_head l e ->
  ((list.Length.length r) < (list.Length.length l))%Z.

Axiom is_removed_length_for_lists :
  forall (l:Init.Datatypes.list (Init.Datatypes.list t7))
    (r:Init.Datatypes.list (Init.Datatypes.list t7)) (e:t7),
  ((list.Length.length r) = (list.Length.length l)) /\
  (forall (i:Numbers.BinNums.Z),
   (0%Z <= i)%Z /\ (i < (list.Length.length l))%Z ->
   is_removed (get (of_list l) i) (get (of_list r) i) e) ->
  forall (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (list.Length.length l))%Z ->
  ((list.Length.length (get (of_list r) i)) <=
   (list.Length.length (get (of_list l) i)))%Z.

Parameter l: Init.Datatypes.list (Init.Datatypes.list t7).

Parameter r: Init.Datatypes.list (Init.Datatypes.list t7).

Axiom H : ((list.Length.length l) = (list.Length.length r)).

Axiom H1 :
  forall (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (list.Length.length l))%Z ->
  ((list.Length.length (get (of_list r) i)) <=
   (list.Length.length (get (of_list l) i)))%Z.

(* Why3 goal *)
Theorem sum_lengths_of_lists : ((sum_lengths r) <= (sum_lengths l))%Z.
Proof.


Qed.

