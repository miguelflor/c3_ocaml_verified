(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require int.Abs.
Require int.MinMax.
Require int.ComputerDivision.
Require int.Power.
Require list.List.
Require list.Length.
Require list.Mem.
Require set.Fset.
Require option.Option.
Require list.Append.
Require list.Reverse.
Require list.RevAppend.
Require list.NumOcc.

(* Why3 assumption *)
Inductive ref (a:Type) :=
  | ref'mk : a -> ref a.
Axiom ref_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (ref a).
Existing Instance ref_WhyType.
Arguments ref'mk {a}.

(* Why3 assumption *)
Definition contents {a:Type} {a_WT:WhyType a} (v:ref a) : a :=
  match v with
  | ref'mk x => x
  end.

(* Why3 assumption *)
Definition fst {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    (x:(a* b)%type) : a :=
  match x with
  | (r, _) => r
  end.

(* Why3 assumption *)
Definition snd {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    (x:(a* b)%type) : b :=
  match x with
  | (_, r) => r
  end.

(* Why3 assumption *)
Inductive result (a:Type)
  (b:Type) :=
  | Ok : a -> result a b
  | Error : b -> result a b.
Axiom result_WhyType : forall (a:Type) {a_WT:WhyType a}
  (b:Type) {b_WT:WhyType b}, WhyType (result a b).
Existing Instance result_WhyType.
Arguments Ok {a} {b}.
Arguments Error {a} {b}.

Parameter same_location: forall {a:Type} {a_WT:WhyType a}, a -> a -> Prop.

Axiom same_location_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (y:a), same_location x y -> (x = y).

Parameter infix_tleq:
  Numbers.BinNums.Z -> Numbers.BinNums.Z -> Init.Datatypes.bool.

Axiom infix_tleq'spec :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  ((infix_tleq x y) = Init.Datatypes.true) <-> ~ (x = y).

(* Why3 assumption *)
Definition is_pre_order {a:Type} {a_WT:WhyType a}
    (cmp:a -> a -> Numbers.BinNums.Z) : Prop :=
  (forall (x:a), ((cmp x x) = 0%Z)) /\
  (forall (x:a) (y:a), ((cmp x y) = 0%Z) <-> ((cmp y x) = 0%Z)) /\
  (forall (x:a) (y:a), ((cmp x y) < 0%Z)%Z <-> (0%Z < (cmp y x))%Z) /\
  (forall (x:a) (y:a) (z:a),
   (((cmp x y) = 0%Z) -> ((cmp y z) = 0%Z) -> ((cmp x z) = 0%Z)) /\
   (((cmp x y) = 0%Z) -> ((cmp y z) < 0%Z)%Z -> ((cmp x z) < 0%Z)%Z) /\
   (((cmp x y) < 0%Z)%Z -> ((cmp y z) = 0%Z) -> ((cmp x z) < 0%Z)%Z) /\
   (((cmp x y) < 0%Z)%Z -> ((cmp y z) < 0%Z)%Z -> ((cmp x z) < 0%Z)%Z)).

Axiom cmp_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (y:a) (cmp:a -> a -> Numbers.BinNums.Z), is_pre_order cmp ->
  ((cmp x y) = 0%Z) <-> (x = y).

Parameter compare:
  forall {a:Type} {a_WT:WhyType a}, a -> a -> Numbers.BinNums.Z.

Axiom compare_pre_order :
  forall {a:Type} {a_WT:WhyType a},
  is_pre_order (fun (x:a) (y:a) => compare x y).

Parameter concat:
  Strings.String.string -> Strings.String.string -> Strings.String.string.

Axiom concat_assoc :
  forall (s1:Strings.String.string) (s2:Strings.String.string)
    (s3:Strings.String.string),
  ((concat (concat s1 s2) s3) = (concat s1 (concat s2 s3))).

Parameter rliteral: Strings.String.string.

Axiom rliteral_axiom : True.

Axiom concat_empty :
  forall (s:Strings.String.string),
  ((concat s rliteral) = (concat rliteral s)) /\ ((concat rliteral s) = s).

Parameter length: Strings.String.string -> Numbers.BinNums.Z.

Axiom length_empty : ((length rliteral) = 0%Z).

Axiom length_concat :
  forall (s1:Strings.String.string) (s2:Strings.String.string),
  ((length (concat s1 s2)) = ((length s1) + (length s2))%Z).

Parameter lt: Strings.String.string -> Strings.String.string -> Prop.

Axiom lt_empty :
  forall (s:Strings.String.string), ~ (s = rliteral) -> lt rliteral s.

Axiom lt_not_com :
  forall (s1:Strings.String.string) (s2:Strings.String.string), lt s1 s2 ->
  ~ lt s2 s1.

Axiom lt_ref : forall (s1:Strings.String.string), ~ lt s1 s1.

Axiom lt_trans :
  forall (s1:Strings.String.string) (s2:Strings.String.string)
    (s3:Strings.String.string),
  lt s1 s2 /\ lt s2 s3 -> lt s1 s3.

Parameter le: Strings.String.string -> Strings.String.string -> Prop.

Axiom le_empty : forall (s:Strings.String.string), le rliteral s.

Axiom le_ref : forall (s1:Strings.String.string), le s1 s1.

Axiom lt_le :
  forall (s1:Strings.String.string) (s2:Strings.String.string), lt s1 s2 ->
  le s1 s2.

Axiom lt_le_eq :
  forall (s1:Strings.String.string) (s2:Strings.String.string), le s1 s2 ->
  lt s1 s2 \/ (s1 = s2).

Axiom le_trans :
  forall (s1:Strings.String.string) (s2:Strings.String.string)
    (s3:Strings.String.string),
  le s1 s2 /\ le s2 s3 -> le s1 s3.

Parameter s_at:
  Strings.String.string -> Numbers.BinNums.Z -> Strings.String.string.

Axiom at_out_of_range :
  forall (s:Strings.String.string) (i:Numbers.BinNums.Z),
  (i < 0%Z)%Z \/ ((length s) <= i)%Z -> ((s_at s i) = rliteral).

Axiom at_empty :
  forall (i:Numbers.BinNums.Z), ((s_at rliteral i) = rliteral).

Axiom at_length :
  forall (s:Strings.String.string) (i:Numbers.BinNums.Z),
  let j := s_at s i in
  ((0%Z <= i)%Z /\ (i < (length s))%Z -> ((length j) = 1%Z)) /\
  (~ ((0%Z <= i)%Z /\ (i < (length s))%Z) -> ((length j) = 0%Z)).

Axiom concat_at :
  forall (s1:Strings.String.string) (s2:Strings.String.string),
  let s := concat s1 s2 in
  forall (i:Numbers.BinNums.Z),
  ((0%Z <= i)%Z /\ (i < (length s1))%Z -> ((s_at s i) = (s_at s1 i))) /\
  (((length s1) <= i)%Z /\ (i < (length s))%Z ->
   ((s_at s i) = (s_at s2 (i - (length s1))%Z))).

Parameter substring:
  Strings.String.string -> Numbers.BinNums.Z -> Numbers.BinNums.Z ->
  Strings.String.string.

Axiom substring_out_of_range :
  forall (s:Strings.String.string) (i:Numbers.BinNums.Z)
    (x:Numbers.BinNums.Z),
  (i < 0%Z)%Z \/ ((length s) <= i)%Z -> ((substring s i x) = rliteral).

Axiom substring_of_length_zero_or_less :
  forall (s:Strings.String.string) (i:Numbers.BinNums.Z)
    (x:Numbers.BinNums.Z),
  (x <= 0%Z)%Z -> ((substring s i x) = rliteral).

Axiom substring_of_empty :
  forall (i:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  ((substring rliteral i x) = rliteral).

Axiom substring_smaller :
  forall (s:Strings.String.string) (i:Numbers.BinNums.Z)
    (x:Numbers.BinNums.Z),
  ((length (substring s i x)) <= (length s))%Z.

Axiom substring_smaller_x :
  forall (s:Strings.String.string) (i:Numbers.BinNums.Z)
    (x:Numbers.BinNums.Z),
  (0%Z <= x)%Z -> ((length (substring s i x)) <= x)%Z.

Axiom substring_length :
  forall (s:Strings.String.string) (i:Numbers.BinNums.Z)
    (x:Numbers.BinNums.Z),
  (0%Z <= x)%Z /\ (0%Z <= i)%Z /\ (i < (length s))%Z ->
  (((length s) < (i + x)%Z)%Z ->
   ((length (substring s i x)) = ((length s) - i)%Z)) /\
  (~ ((length s) < (i + x)%Z)%Z -> ((length (substring s i x)) = x)).

Axiom substring_at :
  forall (s:Strings.String.string) (i:Numbers.BinNums.Z),
  ((s_at s i) = (substring s i 1%Z)).

Axiom substring_substring :
  forall (s:Strings.String.string) (ofs:Numbers.BinNums.Z)
    (len:Numbers.BinNums.Z) (ofs':Numbers.BinNums.Z) (len':Numbers.BinNums.Z),
  (0%Z <= ofs)%Z /\ (ofs <= (length s))%Z -> (0%Z <= len)%Z ->
  ((ofs + len)%Z <= (length s))%Z -> (0%Z <= ofs')%Z /\ (ofs' <= len)%Z ->
  (0%Z <= len')%Z -> ((ofs' + len')%Z <= len)%Z ->
  ((substring (substring s ofs len) ofs' len') =
   (substring s (ofs + ofs')%Z len')).

Axiom concat_substring :
  forall (s:Strings.String.string) (ofs:Numbers.BinNums.Z)
    (len:Numbers.BinNums.Z) (len':Numbers.BinNums.Z),
  (0%Z <= ofs)%Z /\ (ofs <= (length s))%Z -> (0%Z <= len)%Z ->
  ((ofs + len)%Z <= (length s))%Z -> (0%Z <= len')%Z ->
  (0%Z <= ((ofs + len)%Z + len')%Z)%Z /\
  (((ofs + len)%Z + len')%Z <= (length s))%Z ->
  ((concat (substring s ofs len) (substring s (ofs + len)%Z len')) =
   (substring s ofs (len + len')%Z)).

Parameter prefixof: Strings.String.string -> Strings.String.string -> Prop.

Axiom prefixof_substring :
  forall (s1:Strings.String.string) (s2:Strings.String.string),
  prefixof s1 s2 <-> (s1 = (substring s2 0%Z (length s1))).

Axiom prefixof_concat :
  forall (s1:Strings.String.string) (s2:Strings.String.string),
  prefixof s1 (concat s1 s2).

Axiom prefixof_empty :
  forall (s2:Strings.String.string), prefixof rliteral s2.

Axiom prefixof_empty2 :
  forall (s1:Strings.String.string), ~ (s1 = rliteral) ->
  ~ prefixof s1 rliteral.

Parameter suffixof: Strings.String.string -> Strings.String.string -> Prop.

Axiom suffixof_substring :
  forall (s1:Strings.String.string) (s2:Strings.String.string),
  suffixof s1 s2 <->
  (s1 = (substring s2 ((length s2) - (length s1))%Z (length s1))).

Axiom suffixof_concat :
  forall (s1:Strings.String.string) (s2:Strings.String.string),
  suffixof s2 (concat s1 s2).

Axiom suffixof_empty :
  forall (s2:Strings.String.string), suffixof rliteral s2.

Axiom suffixof_empty2 :
  forall (s1:Strings.String.string), ~ (s1 = rliteral) ->
  ~ suffixof s1 rliteral.

Parameter contains: Strings.String.string -> Strings.String.string -> Prop.

Axiom contains_prefixof :
  forall (s1:Strings.String.string) (s2:Strings.String.string),
  prefixof s1 s2 -> contains s2 s1.

Axiom contains_suffixof :
  forall (s1:Strings.String.string) (s2:Strings.String.string),
  suffixof s1 s2 -> contains s2 s1.

Axiom contains_empty :
  forall (s2:Strings.String.string), contains rliteral s2 <-> (s2 = rliteral).

Axiom contains_empty2 :
  forall (s1:Strings.String.string), contains s1 rliteral.

Axiom contains_substring :
  forall (s1:Strings.String.string) (s2:Strings.String.string)
    (i:Numbers.BinNums.Z),
  ((substring s1 i (length s2)) = s2) -> contains s1 s2.

Axiom contains_concat :
  forall (s1:Strings.String.string) (s2:Strings.String.string),
  contains (concat s1 s2) s1 /\ contains (concat s1 s2) s2.

Axiom contains_at :
  forall (s1:Strings.String.string) (s2:Strings.String.string)
    (i:Numbers.BinNums.Z),
  ((s_at s1 i) = s2) -> contains s1 s2.

Parameter indexof:
  Strings.String.string -> Strings.String.string -> Numbers.BinNums.Z ->
  Numbers.BinNums.Z.

Axiom indexof_empty :
  forall (s:Strings.String.string) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= (length s))%Z -> ((indexof s rliteral i) = i).

Axiom indexof_empty1 :
  forall (s:Strings.String.string) (i:Numbers.BinNums.Z),
  let j := indexof rliteral s i in
  (j = (-1%Z)%Z) \/ (s = rliteral) /\ (i = j) /\ (j = 0%Z).

Axiom indexof_contains :
  forall (s1:Strings.String.string) (s2:Strings.String.string),
  let j := indexof s1 s2 0%Z in
  contains s1 s2 ->
  ((0%Z <= j)%Z /\ (j <= (length s1))%Z) /\
  ((substring s1 j (length s2)) = s2).

Axiom contains_indexof :
  forall (s1:Strings.String.string) (s2:Strings.String.string)
    (i:Numbers.BinNums.Z),
  (0%Z <= (indexof s1 s2 i))%Z -> contains s1 s2.

Axiom not_contains_indexof :
  forall (s1:Strings.String.string) (s2:Strings.String.string)
    (i:Numbers.BinNums.Z),
  ~ contains s1 s2 -> ((indexof s1 s2 i) = (-1%Z)%Z).

Axiom substring_indexof :
  forall (s1:Strings.String.string) (s2:Strings.String.string)
    (i:Numbers.BinNums.Z),
  let j := indexof s1 s2 i in
  (0%Z <= j)%Z -> ((substring s1 j (length s2)) = s2).

Axiom indexof_out_of_range :
  forall (i:Numbers.BinNums.Z) (s1:Strings.String.string)
    (s2:Strings.String.string),
  ~ ((0%Z <= i)%Z /\ (i <= (length s1))%Z) -> ((indexof s1 s2 i) = (-1%Z)%Z).

Axiom indexof_in_range :
  forall (s1:Strings.String.string) (s2:Strings.String.string)
    (i:Numbers.BinNums.Z),
  let j := indexof s1 s2 i in
  (0%Z <= i)%Z /\ (i <= (length s1))%Z ->
  (j = (-1%Z)%Z) \/ (i <= j)%Z /\ (j <= (length s1))%Z.

Axiom indexof_contains_substring :
  forall (s1:Strings.String.string) (s2:Strings.String.string)
    (i:Numbers.BinNums.Z),
  ((0%Z <= i)%Z /\ (i <= (length s1))%Z) /\
  contains (substring s1 i ((length s1) - i)%Z) s2 ->
  (i <= (indexof s1 s2 i))%Z /\ ((indexof s1 s2 i) <= (length s1))%Z.

Parameter replace:
  Strings.String.string -> Strings.String.string -> Strings.String.string ->
  Strings.String.string.

Axiom replace_empty :
  forall (s1:Strings.String.string) (s3:Strings.String.string),
  ((replace s1 rliteral s3) = (concat s3 s1)).

Axiom replace_not_contains :
  forall (s1:Strings.String.string) (s2:Strings.String.string)
    (s3:Strings.String.string),
  ~ contains s1 s2 -> ((replace s1 s2 s3) = s1).

Axiom replace_empty2 :
  forall (s2:Strings.String.string) (s3:Strings.String.string),
  let s4 := replace rliteral s2 s3 in
  ((s2 = rliteral) -> (s4 = s3)) /\ (~ (s2 = rliteral) -> (s4 = rliteral)).

Axiom replace_substring_indexof :
  forall (s1:Strings.String.string) (s2:Strings.String.string)
    (s3:Strings.String.string),
  let j := indexof s1 s2 0%Z in
  ((j < 0%Z)%Z -> ((replace s1 s2 s3) = s1)) /\
  (~ (j < 0%Z)%Z ->
   ((replace s1 s2 s3) =
    (concat (concat (substring s1 0%Z j) s3)
     (substring s1 (j + (length s2))%Z (((length s1) - j)%Z - (length s2))%Z)))).

Parameter replaceall:
  Strings.String.string -> Strings.String.string -> Strings.String.string ->
  Strings.String.string.

Axiom replaceall_empty1 :
  forall (s1:Strings.String.string) (s3:Strings.String.string),
  ((replaceall s1 rliteral s3) = s1).

Axiom not_contains_replaceall :
  forall (s1:Strings.String.string) (s2:Strings.String.string)
    (s3:Strings.String.string),
  ~ contains s1 s2 -> ((replaceall s1 s2 s3) = s1).

Parameter to_int: Strings.String.string -> Numbers.BinNums.Z.

Axiom to_int_gt_minus_1 :
  forall (s:Strings.String.string), ((-1%Z)%Z <= (to_int s))%Z.

Axiom to_int_empty : ((to_int rliteral) = (-1%Z)%Z).

(* Why3 assumption *)
Definition is_digit (s:Strings.String.string) : Prop :=
  ((0%Z <= (to_int s))%Z /\ ((to_int s) <= 9%Z)%Z) /\ ((length s) = 1%Z).

Parameter from_int: Numbers.BinNums.Z -> Strings.String.string.

Axiom from_int_negative :
  forall (i:Numbers.BinNums.Z), (i < 0%Z)%Z <-> ((from_int i) = rliteral).

Axiom from_int_to_int :
  forall (i:Numbers.BinNums.Z),
  ((0%Z <= i)%Z -> ((to_int (from_int i)) = i)) /\
  (~ (0%Z <= i)%Z -> ((to_int (from_int i)) = (-1%Z)%Z)).

Axiom seq : forall (a:Type), Type.
Parameter seq_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (seq a).
Existing Instance seq_WhyType.

Parameter length1:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z.

Axiom length_nonnegative :
  forall {a:Type} {a_WT:WhyType a}, forall (s:seq a), (0%Z <= (length1 s))%Z.

Parameter get:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> a.

Parameter infix_eqeq:
  forall {a:Type} {a_WT:WhyType a}, seq a -> seq a -> Prop.

Axiom infix_eqeq'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a),
  infix_eqeq s1 s2 <->
  ((length1 s1) = (length1 s2)) /\
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (length1 s1))%Z ->
   ((get s1 i) = (get s2 i))).

Axiom infix_eqeq'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a), infix_eqeq s1 s2 -> (s1 = s2).

Parameter create:
  forall {a:Type} {a_WT:WhyType a}, Numbers.BinNums.Z ->
  (Numbers.BinNums.Z -> a) -> seq a.

Axiom create'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (len:Numbers.BinNums.Z) (f:Numbers.BinNums.Z -> a),
  (0%Z <= len)%Z -> ((length1 (create len f)) = len).

Axiom create'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (len:Numbers.BinNums.Z) (f:Numbers.BinNums.Z -> a),
  (0%Z <= len)%Z -> forall (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < len)%Z -> ((get (create len f) i) = (f i)).

Parameter empty: forall {a:Type} {a_WT:WhyType a}, seq a.

Axiom empty'def :
  forall {a:Type} {a_WT:WhyType a}, ((length1 (empty : seq a)) = 0%Z).

Parameter set:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> a -> seq a.

Parameter result1:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> a ->
  Numbers.BinNums.Z -> a.

Axiom result'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a) (j:Numbers.BinNums.Z),
  ((j = i) -> ((result1 s i v j) = v)) /\
  (~ (j = i) -> ((result1 s i v j) = (get s j))).

Axiom set'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length1 s))%Z ->
  ((set s i v) = (create (length1 s) (result1 s i v))).

Axiom set'spec'1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length1 s))%Z ->
  ((length1 (set s i v)) = (length1 s)).

Axiom set'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length1 s))%Z -> ((get (set s i v) i) = v).

Axiom set'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length1 s))%Z -> forall (j:Numbers.BinNums.Z),
  ((0%Z <= j)%Z /\ (j < (length1 s))%Z) /\ ~ (j = i) ->
  ((get (set s i v) j) = (get s j)).

Parameter mixfix_lblsmnrb:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> a -> seq a.

Axiom mixfix_lblsmnrb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length1 s))%Z ->
  ((mixfix_lblsmnrb s i v) = (set s i v)).

(* Why3 assumption *)
Definition singleton {a:Type} {a_WT:WhyType a} (v:a) : seq a :=
  create 1%Z (fun (us:Numbers.BinNums.Z) => v).

Axiom singleton'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (v:a), ((length1 (singleton v)) = 1%Z).

Axiom singleton'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (v:a), ((get (singleton v) 0%Z) = v).

Parameter result2:
  forall {a:Type} {a_WT:WhyType a}, a -> seq a -> Numbers.BinNums.Z -> a.

Axiom result'def1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:seq a) (i:Numbers.BinNums.Z),
  ((i = 0%Z) -> ((result2 x s i) = x)) /\
  (~ (i = 0%Z) -> ((result2 x s i) = (get s (i - 1%Z)%Z))).

(* Why3 assumption *)
Definition cons {a:Type} {a_WT:WhyType a} (x:a) (s:seq a) : seq a :=
  create (1%Z + (length1 s))%Z (result2 x s).

Axiom cons'spec'1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:seq a), ((length1 (cons x s)) = (1%Z + (length1 s))%Z).

Axiom cons'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:seq a), ((get (cons x s) 0%Z) = x).

Axiom cons'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:seq a), forall (i:Numbers.BinNums.Z),
  (0%Z < i)%Z /\ (i <= (length1 s))%Z ->
  ((get (cons x s) i) = (get s (i - 1%Z)%Z)).

Parameter result3:
  forall {a:Type} {a_WT:WhyType a}, seq a -> a -> Numbers.BinNums.Z -> a.

Axiom result'def2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (x:a) (i:Numbers.BinNums.Z),
  ((i = (length1 s)) -> ((result3 s x i) = x)) /\
  (~ (i = (length1 s)) -> ((result3 s x i) = (get s i))).

(* Why3 assumption *)
Definition snoc {a:Type} {a_WT:WhyType a} (s:seq a) (x:a) : seq a :=
  create (1%Z + (length1 s))%Z (result3 s x).

Axiom snoc'spec'1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (x:a), ((length1 (snoc s x)) = (1%Z + (length1 s))%Z).

Axiom snoc'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (x:a), ((get (snoc s x) (length1 s)) = x).

Axiom snoc'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (x:a), forall (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (length1 s))%Z -> ((get (snoc s x) i) = (get s i)).

Parameter mixfix_lbdtdtrb:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z ->
  Numbers.BinNums.Z -> seq a.

Axiom mixfix_lbdtdtrb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= j)%Z /\ (j <= (length1 s))%Z ->
  ((mixfix_lbdtdtrb s i j) =
   (create (j - i)%Z (fun (k:Numbers.BinNums.Z) => get s (i + k)%Z))).

Axiom mixfix_lbdtdtrb'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= j)%Z /\ (j <= (length1 s))%Z ->
  ((length1 (mixfix_lbdtdtrb s i j)) = (j - i)%Z).

Axiom mixfix_lbdtdtrb'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= j)%Z /\ (j <= (length1 s))%Z ->
  forall (k:Numbers.BinNums.Z), (0%Z <= k)%Z /\ (k < (j - i)%Z)%Z ->
  ((get (mixfix_lbdtdtrb s i j) k) = (get s (i + k)%Z)).

Parameter mixfix_lb_dtdtrb:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> seq a.

Axiom mixfix_lb_dtdtrb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= (length1 s))%Z ->
  ((mixfix_lb_dtdtrb s i) = (mixfix_lbdtdtrb s i (length1 s))).

Parameter mixfix_lbdtdt_rb:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> seq a.

Axiom mixfix_lbdtdt_rb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (j:Numbers.BinNums.Z),
  (0%Z <= j)%Z /\ (j <= (length1 s))%Z ->
  ((mixfix_lbdtdt_rb s j) = (mixfix_lbdtdtrb s 0%Z j)).

Parameter result4:
  forall {a:Type} {a_WT:WhyType a}, seq a -> seq a -> Numbers.BinNums.Z ->
  Numbers.BinNums.Z -> a.

Axiom result'def3 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a) (l:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  ((i < l)%Z -> ((result4 s1 s2 l i) = (get s1 i))) /\
  (~ (i < l)%Z -> ((result4 s1 s2 l i) = (get s2 (i - l)%Z))).

(* Why3 assumption *)
Definition infix_plpl {a:Type} {a_WT:WhyType a} (s1:seq a) (s2:seq a) : seq a :=
  let l := length1 s1 in create (l + (length1 s2))%Z (result4 s1 s2 l).

Axiom infix_plpl'spec'1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a),
  ((length1 (infix_plpl s1 s2)) = ((length1 s1) + (length1 s2))%Z).

Axiom infix_plpl'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a), forall (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (length1 s1))%Z ->
  ((get (infix_plpl s1 s2) i) = (get s1 i)).

Axiom infix_plpl'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a), forall (i:Numbers.BinNums.Z),
  ((length1 s1) <= i)%Z /\ (i < (length1 (infix_plpl s1 s2)))%Z ->
  ((get (infix_plpl s1 s2) i) = (get s2 (i - (length1 s1))%Z)).

Axiom my_array : forall (a:Type), Type.
Parameter my_array_WhyType :
  forall (a:Type) {a_WT:WhyType a}, WhyType (my_array a).
Existing Instance my_array_WhyType.

Parameter elts: forall {a:Type} {a_WT:WhyType a}, my_array a -> seq a.

Parameter length2:
  forall {a:Type} {a_WT:WhyType a}, my_array a -> Numbers.BinNums.Z.

Axiom my_array'invariant :
  forall {a:Type} {a_WT:WhyType a},
  forall (self:my_array a),
  (0%Z <= (length2 self))%Z /\ ((length2 self) = (length1 (elts self))).

(* Why3 assumption *)
Definition mixfix_lbrb {a:Type} {a_WT:WhyType a} (a1:my_array a)
    (i:Numbers.BinNums.Z) : a :=
  get (elts a1) i.

Parameter to_list_range:
  forall {a:Type} {a_WT:WhyType a}, my_array a -> Numbers.BinNums.Z ->
  Numbers.BinNums.Z -> Init.Datatypes.list a.

Axiom to_list_range'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:my_array a) (l:Numbers.BinNums.Z) (u:Numbers.BinNums.Z),
  (0%Z <= l)%Z /\ (u <= (length2 a1))%Z ->
  ((u <= l)%Z -> ((to_list_range a1 l u) = Init.Datatypes.nil)) /\
  (~ (u <= l)%Z ->
   ((to_list_range a1 l u) =
    (Init.Datatypes.cons (mixfix_lbrb a1 l) (to_list_range a1 (l + 1%Z)%Z u)))).

Axiom to_list_append :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:my_array a) (l:Numbers.BinNums.Z) (m:Numbers.BinNums.Z)
    (u:Numbers.BinNums.Z),
  (0%Z <= l)%Z /\ (l <= m)%Z /\ (m <= u)%Z /\ (u <= (length2 a1))%Z ->
  ((Init.Datatypes.app (to_list_range a1 l m) (to_list_range a1 m u)) =
   (to_list_range a1 l u)).

(* Why3 assumption *)
Definition mem {a:Type} {a_WT:WhyType a} (x:a) (s:seq a) : Prop :=
  exists i:Numbers.BinNums.Z,
  ((0%Z <= i)%Z /\ (i < (length1 s))%Z) /\ ((get s i) = x).

Axiom mem_append :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s1:seq a) (s2:seq a),
  mem x (infix_plpl s1 s2) <-> mem x s1 \/ mem x s2.

Axiom mem_tail :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:seq a), (0%Z < (length1 s))%Z ->
  mem x s <-> (x = (get s 0%Z)) \/ mem x (mixfix_lb_dtdtrb s 1%Z).

(* Why3 assumption *)
Definition mem1 {a:Type} {a_WT:WhyType a} (x:a) (a1:my_array a) : Prop :=
  mem x (elts a1).

(* Why3 assumption *)
Definition array (a:Type) := my_array a.

Parameter max_array_length: Numbers.BinNums.Z.

Axiom non_neg_max_array_length : (0%Z < max_array_length)%Z.

(* Why3 assumption *)
Fixpoint map {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b} (f:a -> b)
  (l:Init.Datatypes.list a) {struct l}: Init.Datatypes.list b :=
  match l with
  | Init.Datatypes.nil => Init.Datatypes.nil
  | Init.Datatypes.cons x r => Init.Datatypes.cons (f x) (map f r)
  end.

(* Why3 assumption *)
Definition set1 (a:Type) := set.Fset.fset a.

(* Why3 assumption *)
Definition t (a:Type) := set.Fset.fset a.

(* Why3 assumption *)
Fixpoint elements {a:Type} {a_WT:WhyType a}
  (l:Init.Datatypes.list a) {struct l}: set.Fset.fset a :=
  match l with
  | Init.Datatypes.nil => set.Fset.empty : set.Fset.fset a
  | Init.Datatypes.cons x r => set.Fset.add x (elements r)
  end.

Axiom elements_mem :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (l:Init.Datatypes.list a),
  list.Mem.mem x l <-> set.Fset.mem x (elements l).

Axiom t1 : forall (a:Type), Type.
Parameter t1_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (t1 a).
Existing Instance t1_WhyType.

Parameter view: forall {a:Type} {a_WT:WhyType a}, t1 a -> seq a.

Axiom t2 : forall (a:Type), Type.
Parameter t2_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (t2 a).
Existing Instance t2_WhyType.

Parameter view1: forall {a:Type} {a_WT:WhyType a}, t2 a -> seq a.

(* Why3 assumption *)
Definition t3 := Strings.String.string.

Parameter compare1:
  Strings.String.string -> Strings.String.string -> Numbers.BinNums.Z.

Axiom compare_pre_order1 :
  is_pre_order
  (fun (y0:Strings.String.string) (y1:Strings.String.string) =>
   compare1 y0 y1).

(* Why3 assumption *)
Definition t4 := Numbers.BinNums.Z.

Parameter compare2:
  Numbers.BinNums.Z -> Numbers.BinNums.Z -> Numbers.BinNums.Z.

Axiom compare_pre_order2 :
  is_pre_order
  (fun (y0:Numbers.BinNums.Z) (y1:Numbers.BinNums.Z) => compare2 y0 y1).

Axiom t5 : Type.
Parameter t5_WhyType : WhyType t5.
Existing Instance t5_WhyType.

Parameter get_parents: t5 -> Init.Datatypes.list t5.

Axiom t6 : Type.
Parameter t6_WhyType : WhyType t6.
Existing Instance t6_WhyType.

Parameter get_parents1: t6 -> Init.Datatypes.list t6.

(* Why3 assumption *)
Fixpoint sum_lengths
  (ll:Init.Datatypes.list (Init.Datatypes.list t6)) {struct ll}: Numbers.BinNums.Z :=
  match ll with
  | Init.Datatypes.nil => 0%Z
  | Init.Datatypes.cons h t7 => ((list.Length.length h) + (sum_lengths t7))%Z
  end.

(* Why3 assumption *)
Definition is_removed (a:Init.Datatypes.list t6) (b:Init.Datatypes.list t6)
    (e:t6) : Prop :=
  match a with
  | Init.Datatypes.nil => (Init.Datatypes.nil = b)
  | Init.Datatypes.cons h t7 =>
      ((h = e) -> (t7 = b)) /\ (~ (h = e) -> (a = b))
  end.

(* Why3 assumption *)
Definition has_head (a:Init.Datatypes.list t6) (e:t6) : Prop :=
  match a with
  | Init.Datatypes.nil => False
  | Init.Datatypes.cons h _ => (h = e)
  end.

(* Why3 assumption *)
Definition tail (l:Init.Datatypes.list t6) : Init.Datatypes.list t6 :=
  match l with
  | Init.Datatypes.nil => Init.Datatypes.nil
  | Init.Datatypes.cons _ t7 => t7
  end.

(* Why3 assumption *)
Fixpoint distinct (l:Init.Datatypes.list t6) {struct l}: Prop :=
  match l with
  | Init.Datatypes.nil => True
  | Init.Datatypes.cons h t7 => ~ list.Mem.mem h t7 /\ distinct t7
  end.

Parameter is_mapped_by_remove:
  Init.Datatypes.list (Init.Datatypes.list t6) ->
  Init.Datatypes.list (Init.Datatypes.list t6) -> t6 -> Prop.

Axiom is_mapped_by_remove'def :
  forall (a:Init.Datatypes.list (Init.Datatypes.list t6))
    (b:Init.Datatypes.list (Init.Datatypes.list t6)) (e:t6),
  match (a, b) with
  | (Init.Datatypes.nil, Init.Datatypes.nil) => is_mapped_by_remove a b e
  | (Init.Datatypes.nil, _) => ~ is_mapped_by_remove a b e
  | (_, Init.Datatypes.nil) => ~ is_mapped_by_remove a b e
  | (Init.Datatypes.cons ha ta, Init.Datatypes.cons hb tb) =>
      is_mapped_by_remove a b e <->
      is_removed ha hb e /\ is_mapped_by_remove ta tb e
  end.

Axiom list_must_eq_dec :
  forall (x:Init.Datatypes.list t6) (y:Init.Datatypes.list t6) (e:t6),
  is_removed x y e -> ((list.Length.length y) <= (list.Length.length x))%Z.

Axiom list_must_dec :
  forall (x:Init.Datatypes.list t6) (y:Init.Datatypes.list t6) (e:t6),
  is_removed x y e ->
  match x with
  | Init.Datatypes.nil => ((list.Length.length x) = (list.Length.length y))
  | Init.Datatypes.cons h _ =>
      ((h = e) -> ((list.Length.length y) < (list.Length.length x))%Z) /\
      (~ (h = e) -> ((list.Length.length x) = (list.Length.length y)))
  end.

Parameter x: Init.Datatypes.list (Init.Datatypes.list t6).

Parameter y: Init.Datatypes.list (Init.Datatypes.list t6).

Parameter e: t6.

Axiom H : ((list.Length.length x) = (list.Length.length y)).

Axiom H1 : is_mapped_by_remove x y e.

Parameter l: Init.Datatypes.list t6.

Axiom H2 : list.Mem.mem l x.

Axiom H3 : has_head l e.

Axiom H4 : list.Mem.mem (tail l) y.

(* Why3 goal *)
Theorem lists_must_dec : ((sum_lengths y) < (sum_lengths x))%Z.
Proof.


Qed.

